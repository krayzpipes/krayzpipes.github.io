<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Kyle Piper">
  <meta name="description" content="Asyncing Feeling | The Back Story &#34;Logging alert - Microsoft Cloud Logs&#34; was the subject of an email that slid into my inbox one morning. I put the...">

  <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
  <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">  
  <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.6/css/bootstrap.min.css" type="text/css" media="all">
  <link rel="stylesheet" href="/theme/css/font.css" type="text/css" media="all">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="/theme/css/style.css" type="text/css" media="all">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:800">

  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.12.3/jquery.min.js"></script>
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/modernizr/2.8.3/modernizr.min.js"></script>
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.6/js/bootstrap.min.js"></script>
  <script type="text/javascript" src="/theme/js/functions.min.js"></script>

  
 


<meta name="keywords" content="Python">

<meta property="og:title" content="Asyncing Feeling">
<meta property="og:type" content="website">
<meta property="og:image" content="/"/>
<meta property="og:image:secure_url" content="/"/>
<meta property="og:site_name" content="">
<meta property="og:description" content="It's difficult to change from a single-threaded mindset to an asynchronous/concurrency mindset in Python. I'm sharing the mental model I use when programming asynchronously with Python in hopes it will help others side-step the learning curve.">
<meta property="og:url" content="http:///articles/asyncing-feeling.html">
<meta property="fb:admins" content=""/>
<meta property="fb:app_id" content=""/>
<script src="/theme/js/lw-timeago.25926835.min.js" type="text/javascript"></script>

  <title>Asyncing Feeling</title>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-134364467-1', 'auto');
  ga('send', 'pageview');

</script>
  
</head>

<body class="home blog">
  <div>
    <header class="site-header">
      <nav class="navbar navbar-default" role="navigation">
        <div class="container">
          <div class="row">
            <div class="site-navigation-inner col-sm-12">
              <div class="navbar-header">
                <button type="button" class="btn navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="icon-bar"></span>
                  <span class="icon-bar"></span>
                  <span class="icon-bar"></span>
                </button>
              </div>
              <div class="collapse navbar-collapse navbar-ex1-collapse">
              <ul id="menu-all-pages" class="nav navbar-nav">
                <li class="menu-item"><a href="/index.html" >Home
<i class="fa  fa-lg"></i></a></li>
                <li class="menu-item"><a href="/pages/about.html" >About
<i class="fa  fa-lg"></i></a></li>
              </ul>
              </div>
              <div class="social">
                <a href="http://github.com/krayzpipes" title="GitHub" >
<i class="fa fa-github fa-lg"></i></a>
              </div>
            </div>
          </div>
        </div>
      </nav><!-- .site-navigation -->

      <div class="container">
      <div id="logo">


<svg viewBox="0 0 1000 110">
  <!-- Symbol-->
  <symbol id="s-text">
    <text text-anchor="middle" x="50%" y="50%" dy=".35em">krayzpipes.io</text>
  </symbol>
  <!-- Duplicate symbols-->
  <use class="svg-text" xlink:href="#s-text"></use>
  <use class="svg-text" xlink:href="#s-text"></use>
  <use class="svg-text" xlink:href="#s-text"></use>
  <use class="svg-text" xlink:href="#s-text"></use>
  <use class="svg-text" xlink:href="#s-text"></use>
</svg>
      </div><!-- end of #logo -->
        <div class="tagline">
                <a href="/tag/python.html" >Python (1)</a> &#124; 
                <a href="/archives.html" >Archives (1)</a>
        </div>
    </div>

  </header><!-- #masthead -->
  </div>
    <div id="content" class="site-content">
      <div class="container main-content-area">
        <div class="row">
          <div class="main-content-inner col-sm-12 col-md-12">
            <div id="primary" class="content-area">
              <div id="main" class="site-main" role="main">
                <div class="article-container">
<article>
  <div class="blog-item-wrap">
    <div class="post-inner-content">
      <header class="entry-header page-header">
        <span class="cat-item"><time datetime="2019-02-12 02:23:00-05:00">Tue 12 February 2019</time></span>
        <h1 class="entry-title"><a href="/asyncing-feeling.html">Asyncing Feeling</a></h1>
      </header><!-- .entry-header -->
      <div class="fb-like" data-href="/asyncing-feeling.html" data-layout="standard" data-action="like" data-show-faces="false" data-share="true"></div>
      <div class="entry-content">
        <h1>The Back Story</h1>
<p>"Logging alert - Microsoft Cloud Logs" was the subject of an email that slid into my inbox one morning.
I put the project I was eager to work on aside in order to address the alert. The alert said
that we had not received Microsoft O365 logs for over an hour. Given that the company in question
consisted of thousands of users and email accounts, that did not seem right.</p>
<h3>Finding the cause</h3>
<p>I jumped onto the server which hosted a script I had written to pull down Microsoft O365 logs. The
server was pegged. I ran a quick <code>ps -aux</code> and there was a legion of python processes </p>
<p>It appeared that the python script was unable to finish before the next cron job was scheduled to kick it
off again. In order to fix this issue, I worked through some possible fixes:</p>
<ul>
<li>Extend the time frame between cron job runs.<ul>
<li>While this seems like a simple fix, it doesn't address the fact that I have more logs being generated
than I can pull down with the script in any given time frame.</li>
</ul>
</li>
<li>Ensure the cron job doesn't kick off a new process if the old one hasn't completed with <code>flock</code>
or a PID file.<ul>
<li>This also seemed like a quick fix at first. While this would keep the script from stepping on its
own toes, it does not help the script pull down the same volume of logs faster. The
first run might take 12 minutes, then the second would take 15 minutes, etc. It would be a snowball
effect.</li>
</ul>
</li>
<li>Figure out a way to pull down logs faster<ul>
<li>In the end, it became apparent that my script just wasn't fast enough. I needed to find a way to
speed it up.</li>
</ul>
</li>
</ul>
<h3>Where I went wrong</h3>
<p>Microsoft O365 logs were really a perfect storm in this scenario:</p>
<ol>
<li>Query the O365 Management API for a list of URLs where the logs I care about are.<ul>
<li>This had to be done for each log type. Ex: Exchange, Azure AD, Sharepoint, etc.</li>
<li>The script specifies a time range. The default is ten minutes.</li>
<li>The script saved the end time of each run so that in the event of a server or API failure, the
script would pick up right where it left off last time.</li>
<li>For a head count of several thousand, this would result in hundreds or thousands of URLs where
logs would need to be retrieved.</li>
</ul>
</li>
<li>Make an API call to each individual URL to pull down whatever logs were available
there.</li>
<li>Write the logs to file so that they could be forwarded and indexed by our log aggregator.</li>
</ol>
<p>With a normal python script, each API call would be made one right after the other. During the time frame
between an API call and the response, the script just sits there because Python is single-threaded
by design.</p>
<p>If I could program for concurrency in Python, I would be able to pull down each log location in parallel
to one another and not waste time 'blocking' the rest of the URLs from being queried.</p>
<h3>Out with the old, in with the new</h3>
<p>After research and some advice from a couple guys in the developer guild I had been trying out,
I decided that it was time I learned to program for concurrency in Python.</p>
<p>The terminology was confusing at first and since I didn't have experience with programming for
concurrency before, it felt like my brain had joined a gymnastics team. I spent the next couple days
working remotely in a coffee shop to escape the constant walk-by question assaults that are so common
with an open office environment. I love helping out my colleagues, but I also needed to focus in on
wrapping my head around programming for concurrency in python.</p>
<p>I eventually got it working. After rewriting the script to use a combination of <code>asyncio</code> and
<code>aiohttp</code>, I was able to pull down roughly thirteen hours of logs (500,000+ logs) in twenty seconds.
Using the original script and the <code>requests</code> library, it took twenty minutes to pull down the
same amount of logs.</p>
<p>I was a bit startled by the performance gains. Now I use <code>asyncio</code> any time I see that my task
at hand is I/O bound.</p>
<p>Although I finally got the script working with concurrency built-in, I had a difficult time changing
from a single-threaded mindset to an asynchronous mindset in Python. In addition, it was a whole new
set of terms and libraries to learn. With this post, I'm sharing the mental model I use when programming
asynchronously with Python in hopes it will help others side-step the learning curve.</p>
<h1>Concepts, Entities, and Relationships</h1>
<h2>Concepts</h2>
<p>I don't want to re-invent the wheel here so I'm including a few links that you should read first if
you don't already know why/how one would program for concurrency in Python:</p>
<ul>
<li><a href="https://realpython.com/python-concurrency/">Real Python: Speed Up Your Python Program With Concurrency</a>.</li>
<li><a href="https://realpython.com/python-gil/">Real Python: What is the Python Global Interpreter Lock (GIL)?</a></li>
</ul>
<p>For our purposes, it is important to note that the O365 script is I/O bound. It 'blocks' the
next instruction from executing every time it waits on a response from the O365 API if you use a
non-asynchronous library like <code>requests</code>.</p>
<p>Another note is that my writing here assumes you are using <code>asyncio</code> in Python 3.5+. The keywords
that <code>asyncio</code> uses in my examples below were not introduced until Python 3.5 (<code>async</code> and
<code>await</code>)</p>
<p>Some of my examples and portions of my 'mental model' are not designed for atomic accuracy. They are
designed so that you can quickly make programming decisions by having a fundamental model to use
as you think about programming for concurrency with Python.</p>
<p>Keep in mind that concurrency programming in Python is a lot like playing a game of
sequential <strong>hot potato</strong> where you can only pass the potato to the next person in line.
I'll explain more in a bit.</p>
<h2>The Entities</h2>
<h3>Futures</h3>
<p>I think of a future as a response. If I'm sending an HTTP GET to a REST API, then a Future would be the
response from that API. It's like a 'promise'. This 'promise' could be an actual return value or just
a notification that a set of instructions has completed execution.</p>
<h3>Coroutines</h3>
<p>A coroutine is a set of instructions created using the <code>async</code> and <code>await</code> keywords. <code>async</code>
let's the interpreter know that the instructions are a coroutine function while <code>await</code>
means, "I'm going to be waiting on some sort of Future (aka response); Therefore, this is a good place
in my instruction execution to allow other things to run while I'm waiting."</p>
<h3>Tasks</h3>
<p>A Task is an entity that knows how/when to wait on a Future and toss the hot potato to another
task while he's waiting for the Future in question.</p>
<p>How does a task know when he is waiting on a Future? He reads the instructions
within the coroutine object that was used to create the task.</p>
<p>Note: I have never had to manually create a Future. Awaiting within a coroutine instruction set
magically handles that for you in most cases.</p>
<h3>Event Loops</h3>
<p>When you want to play hot potato (be given control to execute your instructions), you have to get in line
with the other tasks. That line (or as our European friends would call, '<strong>queue</strong>') is the event loop.
It's a place where tasks go to be in a 'queue' so that they can be given a turn at executing their
instructions.</p>
<h2>Relationships</h2>
<ul>
<li>A future is a promise that you will get something in return (even if it is just a notification that
an instruction set has completed). A Task knows how/when to wait on a Future (promise).</li>
<li>A coroutine is a set of instructions that can have a point of 'waiting'. A task is created from a
coroutine.</li>
<li>The task handles/knows three things:<ol>
<li>When it's his turn in the event loop to execute the coroutine instructions.</li>
<li>Handles sending/receiving the Future.</li>
<li>Throwing the hot potato to the next guy when the coroutine instructions are awaiting a Future.</li>
</ol>
</li>
<li>The event loop is a queue of tasks. When one task says "I'm waiting on something", the event loop
will pass the potato to another task to execute.</li>
</ul>
<p>All of this event loop scheduling and such happens in the background.</p>
<p>A rule of thumb I use is: "If this set of instructions / coroutine will be waiting on a Future (response)
of any kind, put it in the event loop (wrap it with a task and put it in the event loop)!"</p>
<h2>Order of operations</h2>
<ol>
<li>Define your instructions (Coroutine)</li>
<li>Dump the coroutine object into the event loop via creating a task or task(s)</li>
<li>Wait for the output (if applicable)</li>
</ol>
<h4>Creating a coroutine</h4>
<p>Here's an example of a simple coroutine in Python 3.5+:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="c1"># Regular function</span>
<span class="k">def</span> <span class="nf">my_function</span><span class="p">(</span><span class="n">duration</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span>  <span class="c1"># This will block any other instructions from being processed.</span>
    <span class="k">return</span> <span class="s2">&quot;I&#39;m done sleeping after {} seconds&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span>


<span class="c1"># Coroutine</span>
<span class="n">async</span> <span class="k">def</span> <span class="nf">my_coroutine</span><span class="p">(</span><span class="n">duration</span><span class="p">):</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span>  <span class="c1"># Lets the event loop give other instructions a turn while we wait.</span>
    <span class="k">return</span> <span class="s2">&quot;I&#39;m done sleeping after {} seconds&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<h4>Running a coroutine</h4>
<p>You cannot call a coroutine like a normal function and expect it to run; However, Python 3.7 gives you
three ways in which you can run a coroutine:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">my_function</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="s2">&quot;I&#39;m done sleeping after 5 seconds&quot;</span>

<span class="n">my_coroutine</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">coroutine</span> <span class="nb">object</span> <span class="n">my_coroutine</span> <span class="n">at</span> <span class="mh">0x7ff576a5bb48</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span>


<span class="kn">import</span> <span class="nn">asyncio</span>

<span class="c1"># Method 1 - Let Pyton handle creating the event loop and such...</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">my_coroutine</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="s2">&quot;I&#39;m done sleeping after 5 seconds&quot;</span>

<span class="c1"># Method 2 - Await it from another coroutine</span>
<span class="n">async</span> <span class="k">def</span> <span class="nf">coro</span><span class="p">(</span><span class="n">duration</span><span class="p">):</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">await</span> <span class="n">my_coroutine</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">text</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">coro</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="s2">&quot;I&#39;m done sleeping after 5 seconds&quot;</span>

<span class="c1"># Method 3 - Creating a single task</span>
<span class="c1"># In this example, I only create a single task which is run.</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">coro</span><span class="p">():</span>
<span class="n">task1</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">my_coroutine</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="n">task2</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">my_coroutine</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="n">task3</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">my_coroutine</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">await</span> <span class="n">task1</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">await</span> <span class="n">task2</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">await</span> <span class="n">task3</span><span class="p">)</span>

<span class="c1"># The following output appears all at the same time since the Futures</span>
<span class="c1"># for task2 and task3 have already completed by the time task1 finishes.</span>

<span class="n">I</span><span class="s1">&#39;m done sleeping for 5 seconds</span>
<span class="n">I</span><span class="s1">&#39;m done sleeping for 3 seconds</span>
<span class="n">I</span><span class="s1">&#39;m done sleeping for 1 seconds</span>
</pre></div>
</td></tr></table>

<h4>"Dumping" into the event loop</h4>
<p>So you have seen how to add a coroutine one at a time into the event loop through methods of
creating tasks, awaiting, or using the asyncio.run() function. But that's not entirely helpful
when you're trying to pull down logs from one-thousand different endpoints at the same time.</p>
<p>This is where the <code>asyncio.gather()</code> coroutine comes in handy. If I need to call out to
one-thousand API endpoints to pull down logs at the same time, you can create all your coroutine
objects witha  list comprehension and then "gather" all of them into the event loop.</p>
<h1>TO BE CONTINUED......</h1>
      </div><!-- .entry-content -->
      <br /><br />
      <div class="article_meta">
        Tags:
          <a href="/tag/python.html">Python</a>      </div>
    </div>
  </div>
</article><!-- #post-## -->
                </div>
              </div><!-- #main -->
          </div><!-- #primary -->
        </div>
      </div><!-- close .row -->
    </div><!-- close .container -->
  </div><!-- close .site-content -->




  <div id="footer-area">
    <footer id="colophon" class="site-footer" role="contentinfo">
      <div class="site-info container">
        <div class="row">
                    <div class="copyright col-md-12">
                        <!--
                    <a href="/pages/privacy-policy">Privacy Policy</a> | 
                    <a href="/feeds/all.atom.xml">Atom Feed</a> | 
                    <a href="/sitemap.xml">Sitemap</a><br />
                    -->
                    This site uses the <a href="https://github.com/limbenjamin/voce">voce</a> theme by <a href="//limbenjamin.com/">Benjamin Lim</a><br />
                    &copy; 2012-2019 <a href="">Kyle Piper</a> </div>
        </div>
      </div><!-- .site-info -->
      <div class="scroll-to-top" style="display: none;"><i class="fa fa-angle-up"></i></div><!-- .scroll-to-top -->
    </footer><!-- #colophon -->
  </div>

  <script type="text/javascript">
    window.addEventListener('load', function(){
    if (window.location.pathname != '/' && window.location.pathname != '/index.html'){
      window.scroll(0, document.getElementById('main').offsetTop);
    }})
  </script>




<script type="text/javascript">window.addEventListener("load", lw_timeago);</script>
</body>
</html>